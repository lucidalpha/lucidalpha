
import requests
import json
import time
from datetime import datetime, timedelta
import concurrent.futures
from futures_config import FUTURES_METADATA

MONTH_CODES = {
    1: 'F', 2: 'G', 3: 'H', 4: 'J', 5: 'K', 6: 'M',
    7: 'N', 8: 'Q', 9: 'U', 10: 'V', 11: 'X', 12: 'Z'
}

# Mapping codes back to month numbers for sorting
CODE_TO_MONTH = {v: k for k, v in MONTH_CODES.items()}

def get_next_contracts(root, exchange, valid_months_str, count=18):
    """
    Generates a list of valid Yahoo Tickers for the next `count` months.
    valid_months_str: e.g. "H,M,U,Z"
    """
    valid_months = [m.strip() for m in valid_months_str.split(',')]
    
    tickers = []
    
    now = datetime.now()
    curr_year = now.year
    curr_month = now.month
    
    # Start looking from Next Month
    # Actually, if we are late in the month, the current month contract might be expired.
    # Safe rule: Start from Current Month + 1, or Current if very early.
    # Simpler: Generate for next 2 years iterate and filter.
    
    candidates = []
    
    # Expand range to include past year (for history slider) and future 4 years
    # We need to ensure we have enough contracts to cover a 3-year window from ANY point in the slider.
    # Yahoo might not return data for expired contracts, but we try the recent past.
    for y in range(curr_year - 1, curr_year + 5):
        for m in range(1, 13):
            # No strict past filtering here, we filter by validity/availability later
            
            code = MONTH_CODES[m]
            if code in valid_months:
                # Yahoo format: ROOT + CODE + YY (2 digits) + .EXCHANGE
                # Example: GCZ25.CMX
                yy = str(y)[-2:]
                ticker = f"{root}{code}{yy}{exchange}"
                
                # Expiry string for sorting: YYYY-MM
                expiry = f"{y}-{m:02d}"
                
                candidates.append({
                    "symbol": ticker,
                    "expiry": expiry,
                    "month_code": code,
                    "year": y
                })
                
    # We want a lot of contracts to ensure 3y span. 
    # If we just break at `count`, we might only get the old ones.
    # Let's take ALL candidates generated by the year range, then slice if needed, 
    # but 5 years * 5-12 contracts is ~60 requests. Manageable in parallel.
    # We will respect `count` if it's very small, but default is now high.
    
    return candidates[:80] # Cap at 80 to be safe

def fetch_price_history_safe(ticker):
    """
    Fetches 5 days of history using Yahoo Chart API directly via requests.
    Returns dict {date_str: close_price} or None if failed.
    """
    url = f"https://query2.finance.yahoo.com/v8/finance/chart/{ticker}"
    params = {
        "range": "1mo", # Get 1 month to ensure we have last few active days
        "interval": "1d"
    }
    headers = {
        'User-Agent': "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko)"
    }
    
    try:
        # Verify=False to avoid SSL issues locally if needed, usually requests handles it better than yf
        # But let's try True first, if error catch.
        r = requests.get(url, params=params, headers=headers, timeout=3)
        if r.status_code != 200:
            return None
            
        data = r.json()
        result = data.get('chart', {}).get('result', [])
        if not result:
            return None
            
        quote = result[0]
        timestamp = quote.get('timestamp', [])
        indicators = quote.get('indicators', {}).get('quote', [{}])[0]
        closes = indicators.get('close', [])
        
        if not timestamp or not closes:
            return None
            
        history = {}
        for t, c in zip(timestamp, closes):
            if c is None: continue
            # Convert timestamp to YYYY-MM-DD
            dt = datetime.fromtimestamp(t).strftime('%Y-%m-%d')
            history[dt] = c
            
        return history
        
    except Exception as e:
        print(f"Error fetching {ticker}: {e}")
        return None

def get_term_structure(base_ticker, max_contracts=80):
    """
    Main function to get term structure.
    base_ticker: e.g. "GC=F"
    max_contracts: increased to see further into future
    """
    start_time = time.time()
    if base_ticker not in FUTURES_METADATA:
        return {"error": f"Asset {base_ticker} not configured for term structure."}
        
    meta = FUTURES_METADATA[base_ticker]
    root = meta['root']
    exchange = meta['exchange']
    months = meta['months']
    
    # 1. Generate Candidates (More contracts)
    contracts = get_next_contracts(root, exchange, months, count=max_contracts)
    
    # 2. Fetch Data in Parallel (Fetch 1y history)
    valid_contracts = []
    
    def fetch_full_history(ticker):
        # Modified to fetch 1y
        url = f"https://query2.finance.yahoo.com/v8/finance/chart/{ticker}"
        params = {
            "range": "2y", # Get 2 years to allow slider to go back
            "interval": "1d"
        }
        headers = {
            'User-Agent': "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko)"
        }
        try:
            r = requests.get(url, params=params, headers=headers, timeout=5)
            if r.status_code != 200: return None
            data = r.json()
            result = data.get('chart', {}).get('result', [])
            if not result: return None
            quote = result[0]
            timestamp = quote.get('timestamp', [])
            indicators = quote.get('indicators', {}).get('quote', [{}])[0]
            closes = indicators.get('close', [])
            
            if not timestamp or not closes: return None
            
            history = {}
            for t, c in zip(timestamp, closes):
                if c is None: continue
                dt = datetime.fromtimestamp(t).strftime('%Y-%m-%d')
                history[dt] = c
            return history
        except:
            return None

    with concurrent.futures.ThreadPoolExecutor(max_workers=20) as executor:
        future_map = {executor.submit(fetch_full_history, c['symbol']): c for c in contracts}
        
        for future in concurrent.futures.as_completed(future_map):
            c = future_map[future]
            try:
                history = future.result()
                if history:
                    # Store entire history
                    valid_contracts.append({
                        "symbol": c['symbol'],
                        "expiry": c['expiry'],
                        "history": history,
                        "label": datetime.strptime(c['expiry'], "%Y-%m").strftime("%b %y")
                    })
            except Exception as e:
                print(f"Failed contract {c['symbol']}: {e}")

    # Sort by expiry (Month of contract)
    valid_contracts.sort(key=lambda x: x['expiry'])
    
    # 3. Aggregate all available dates for the slider
    all_dates = set()
    for c in valid_contracts:
        all_dates.update(c['history'].keys())
    
    sorted_dates = sorted(list(all_dates)) # Ascending for slider [Oldest ... Newest]
    
    print(f"Term structure for {base_ticker} fetched in {time.time() - start_time:.2f}s. Dates: {len(sorted_dates)}")
    
    return {
        "ticker": base_ticker,
        "name": meta['name'],
        "dates": sorted_dates,     # For Slider
        "contracts": valid_contracts # Data source
    }
